\section{BTB-X}
\label{hpca:sec:design}

BTB-X is a simple and storage-effective BTB organization. Building on the insights gained in \Cref{hpca:sec:analysis}, it stores target offsets, instead of full targets, to minimize storage requirements while also accounting for the large variance in target offset sizes. Its microarchitecture and entry/set composition are shown in \Cref{hpca:fig:btbx}.

\subsection{BTB-X Organization}

The offset field in BTB-X needs to accommodate the uneven distribution of target offset sizes as observed in \Cref{hpca:sec:analysis}. In principle, this field should be sized such that the BTB can store the largest target offset. However, as the largest offset can be nearly as large as the full target, sizing the \textit{offset} field this way would nearly eliminate the potential storage saving from storing offsets. An attractive alternative is to size the offset field such that it can store the majority of offsets. Looking at \Cref{hpca:fig:offsets}, an \textit{offset} field of 25-bits would capture more than 99\% of branch target offsets as they requires 25-bits or fewer. However, there are two major drawbacks to this scheme. First, it still leads to poor storage utilization. This is because, as \Cref{hpca:fig:offsets} implies, 54\% of branches would waste more than three quarters of \textit{offset} storage capacity as they require only 6-bits or fewer for their offsets. Another 25\% of branches would waste nearly half of the offset storage as their offsets fit in 7-12 bits. Second, all branches that need more than 25 bits for their offsets can not fit in the BTB and will always cause BTB misses. Though, as there are very few such branches (< 1\%), their impact is likely to be small.

To minimize the storage under-utilization, we size different ways of a set associative BTB-X to hold different sized target offsets. A branch is allocated to a way whose offset field is at least as large as the number of bit required to store the target offset. We use an 8-way set associative BTB-X and leverage the data in \Cref{hpca:fig:offsets} to appropriately size the offset field of each way such that each way covers about 12.5\% dynamically executed branches. \Cref{hpca:fig:offsets} shows that, on average, 0-, 4-, 5-, 7-, 9-, 11-, 19-, and 25-bit offsets cover about 20\%, 36\%, 46\%, 61\%, 72\%, 79\%, 90\%, and 99\% dynamic branches. Therefore, we size the 8-ways of BTB-X ways to hold 0-, 4-, 5-, 7-, 9-, 11-, 19-, and 25-bit target offsets respectively. Notice that about 20\% of dynamic branches that require 0-bits for their offset are return instructions that read their target from RAS, as discussed in \Cref{hpca:sec:background}. Therefore, way-0 of BTB-X does not feature any storage for target offsets. Though return instruction do not get their target from BTB, they still need to be allocated BTB entries so that the branch prediction unit can identify them and pick their target from RAS while generating instruction stream to be fetched.

BTB-X covers 99\% of the dynamically executed branches and we employ a very small conventional direct-mapped BTB, called BTB-XC, that stores full target addresses for the remaining 1\% branches. Reserving a way in BTB-X for such branches would unnecessarily increase the storage requirements as these branches require much fewer entries than the number of sets in BTB-X. Indeed, based on our analysis, we size BTB-XC to store 64x fewer entries than BTB-X, i,e, 8x fewer entries than the number of sets in BTB-X.

\subsection{Accessing BTB-X}

\subsubsection{BTB-X Lookup}
A BTB-X lookup is very similar to a conventional BTB lookup as shown in \Cref{hpca:fig:btbx}. It is accessed with the index bits of a PC and all eight ways are looked up in parallel. Also, BTB-XC is looked up in parallel with BTB-X. The main difference between a conventional BTB lookup and BTB-X lookup is that a BTB-X lookup provides target offset, rather than full target address, if the lookup hits in way-1 to way-7. Thus, target offset needs to be concatenated with branch PC to get the full target address. The number of bits to be concatenated from branch PC depends on the BTB-X way in which the lookup hits. For example, a hit in way-1 provides 4 lower order bits of target while the rest needs to be concatenated from branch PC. Further, a hit in way-0 implies that the full target is in RAS, while a hit in BTB-XC provides the full target address.

\subsubsection{BTB-X Allocation}
As with any existing BTB organization, BTB-X entries are allocated (or updated) as branch instructions retire. The number of bits required to represent a branch target offset determines the way(s) where a branch can be allocated an entry. For example, return instructions can be allocated entries in any of the ways, based on replacement policy's decision, as they have no offset and can fit in all ways. Other branches have fewer ways where they can be allocated entries that are determined by the minimum number of bits required to store their offsets. For example, if a branch requires 20 bits for its target offset, it cannot be allocated in way-0 to way-6.

BTB-X uses a slightly modified least recently used (LRU) replacement policy. Concretely, we modify it to compare the LRU counters of only the entries that can accommodate the target offset and replace the one that is least recently used among them. All other aspect of LRU, such as counter updates, stay exactly the same as in baseline policy.

%\subsection{Applicability to Other BTB Designs}
%\label{hpca:sec:aplicability}
%While we present BTB-X in the context of an instruction-based BTB design (i.e., the BTB is accessed using individual instruction addresses), our insights and design are equally applicable to other BTB designs as well. For example, as basic-block and fetch-block based BTBs (BBTB and FBTB) also store full target addresses, they also experience gross storage under-utilization just like an IBTB. Therefore, our idea of partitioning the BTB and storing branch offsets, instead of full targets, can be leveraged to improve the storage density and utilization of these BTB organizations as well.

%The BTB designs that store more than one target per entry, such as Air-BTB and AMD style BTB, will also benefit from storing offsets instead of full targets. However, the BTB partitioning mechanism might need some adjustments. The simplest partitioning scheme would be to partition the BTB in the same way as an IBTB and size the all the offset fields in a BTB entry of a given partition equally. However, this scheme will provide sub-optimal results if different branches in a BTB entry require very dissimilar number of bits for their offsets and cannot be accommodated within the same partition. For example, one offset needs 3-bits while the other requires 10-bits. In this case, an entry would need to be allocated in "14-bit offset" partition even though one of the offsets needs only 3-bits, thus wasting BTB storage. Another solution is to introduce more partitions to cover all combinations of different offset sizes (0, 7, 14, 24, and 46-bits). However, this scheme would result in prohibitively high number of total partitions. 

%A better scheme would be to partition the BTB just like an IBTB, but dynamically share the offset storage space among all branches in an entry, rather than statically distributing it among them. For example, in the "7-bit offset" partition with two branches per entry, the 14 bits of offset storage space can be dynamically shared among the branches. Consequently, an entry can accommodate a branch that requires more than 7-bits for its offset if the other branch requires fewer bits and the total does not exceed 14 bits. However, this scheme requires an additional field in a BTB entry to mark the boundary between the two branch offsets.
